<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reflection on Course</title>
    <link rel="stylesheet" href="style-refc.css">
</head>
<body>
    <!-- Navigation Bar -->
    <nav>
        <ul>
            <li><a href="index.html">Home</a></li>
            <li class="dropdown">
                <a href="daa.html">DAA</a>
                <ul class="dropdown-menu">
                    <li><a href="project.html">Course Project Introduction</a></li>
                    <li><a href="reflectiononcourse.html">Reflection on Course</a></li>
                    <li><a href="reflectiononproblem.html">Reflection on Problem Solving Skills</a></li>
                </ul>
            </li>
        </ul>
    </nav>

    <!-- Header Section -->
    <header>
        <h1>Reflection on Course</h1>
    </header>

    <!-- Main Content Section -->
    <section>
        <h2>Reflection Questions and Answers</h2>

        <h3>1. What are the kinds of problems we see in nature? (iteration, recursion, backtracking)</h3>
        <p>Nature demonstrates problems involving iteration, recursion, and backtracking:</p>
        <ul>
            <li><strong>Iteration:</strong> Repetitive processes like seasonal changes or animal migration.</li>
            <li><strong>Recursion:</strong> Fractal patterns in leaves and snowflakes that repeat at different scales.</li>
            <li><strong>Backtracking:</strong> Trial-and-error approaches used by animals in finding food or navigating obstacles.</li>
        </ul>

        <h3>2. What is space and time efficiency? Why are they important? Explain the different classes of problems and orders of growth.</h3>
        <p>Space and time efficiency measure memory usage and runtime of algorithms. They are critical for scalable and performant solutions, especially for large datasets.</p>
        <p><strong>Classes of problems:</strong></p>
        <ul>
            <li><strong>Polynomial Time (P):</strong> Problems solvable efficiently, like sorting.</li>
            <li><strong>Non-deterministic Polynomial (NP):</strong> Problems verifiable in polynomial time but not efficiently solvable, like the Traveling Salesman Problem.</li>
            <li><strong>NP-complete:</strong> The hardest NP problems reducible to each other.</li>
        </ul>
        <p><strong>Orders of growth:</strong> O(1), O(log n), O(n), O(n²), O(2ⁿ), and O(n!).</p>

        <h3>3. Take away from different design principles from Chapter 2.</h3>
        <ul>
            <li><strong>Divide-and-Conquer:</strong> Breaks problems into smaller parts (e.g., Merge Sort).</li>
            <li><strong>Greedy Algorithms:</strong> Focuses on the best local option at each step (e.g., Kruskal’s Algorithm).</li>
            <li><strong>Dynamic Programming:</strong> Optimizes overlapping subproblems (e.g., Longest Common Subsequence).</li>
        </ul>

        <h3>4. The hierarchical data and how different tree data structures solve and optimize over problem scenarios.</h3>
        <ul>
            <li><strong>Binary Search Tree:</strong> Efficient for searches and updates.</li>
            <li><strong>AVL Tree:</strong> A self-balancing BST for consistent performance.</li>
            <li><strong>Red-Black Tree:</strong> Ensures balance and is widely used in databases.</li>
            <li><strong>Heap:</strong> Used in priority queues.</li>
            <li><strong>Trie:</strong> Optimized for prefix searches (e.g., autocomplete).</li>
        </ul>

        <h3>5. The need for array query algorithms and their implications.</h3>
        <p>Array query algorithms like Segment Trees and Fenwick Trees allow efficient range queries and updates, essential in:</p>
        <ul>
            <li>Database indexing.</li>
            <li>Real-time dashboards.</li>
            <li>Game leaderboards.</li>
        </ul>

        <h3>6. Differentiate between trees and graphs and their traversals.</h3>
        <p><strong>Trees:</strong> Hierarchical structures with a root (e.g., file systems).</p>
        <p><strong>Graphs:</strong> Generalized node-edge structures (e.g., social networks).</p>
        <p>Traversals: Preorder, Inorder, Postorder (trees); BFS and DFS (graphs).</p>

        <h3>7. Deliberate on sorting and searching algorithms, the technique behind each, and their connection to the real world.</h3>
        <ul>
            <li><strong>Sorting:</strong> Organizes data for search efficiency (e.g., Quick Sort).</li>
            <li><strong>Searching:</strong> Retrieves data efficiently (e.g., Binary Search).</li>
        </ul>

        <h3>8. Discuss the importance of graph algorithms with respect to spanning trees and shortest paths.</h3>
        <p>Graph algorithms optimize networks:</p>
        <ul>
            <li><strong>Spanning Trees:</strong> Kruskal’s and Prim’s algorithms optimize connections.</li>
            <li><strong>Shortest Path:</strong> Dijkstra’s algorithm finds optimal routes.</li>
        </ul>

        <h3>9. Discuss about the different studied algorithm design techniques.</h3>
        <ul>
            <li><strong>Divide-and-Conquer:</strong> Breaks problems into subproblems (e.g., Quick Sort).</li>
            <li><strong>Greedy Algorithms:</strong> Focuses on immediate optimization (e.g., Huffman Coding).</li>
            <li><strong>Dynamic Programming:</strong> Optimizes solutions with overlapping subproblems (e.g., Knapsack Problem).</li>
        </ul>
    </section>
</body>
</html>
